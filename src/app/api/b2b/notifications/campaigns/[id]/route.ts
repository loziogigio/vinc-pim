/**
 * Single Campaign API
 *
 * GET /api/b2b/notifications/campaigns/[id] - Get campaign
 * PUT /api/b2b/notifications/campaigns/[id] - Update draft
 * DELETE /api/b2b/notifications/campaigns/[id] - Delete campaign
 */

import { NextRequest, NextResponse } from "next/server";
import { authenticateTenant } from "@/lib/auth/tenant-auth";
import { connectWithModels } from "@/lib/db/connection";
import {
  TEMPLATE_TYPES,
  NOTIFICATION_CHANNELS,
  RECIPIENT_TYPES,
} from "@/lib/constants/notification";

// ============================================
// GET - Get single campaign
// ============================================

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const auth = await authenticateTenant(req);
    if (!auth.authenticated || !auth.tenantDb) {
      return NextResponse.json({ error: auth.error || "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;
    const tenantDb = auth.tenantDb;
    const { Campaign } = await connectWithModels(tenantDb);

    const campaign = await Campaign.findOne({ campaign_id: id }).lean();

    if (!campaign) {
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 });
    }

    return NextResponse.json({ campaign });
  } catch (error) {
    console.error("Error fetching campaign:", error);
    return NextResponse.json(
      { error: "Failed to fetch campaign" },
      { status: 500 }
    );
  }
}

// ============================================
// PUT - Update draft campaign
// ============================================

interface UpdateCampaignPayload {
  name?: string;
  type?: "product" | "generic";
  title?: string;
  body?: string;
  push_image?: string;
  email_subject?: string;
  email_html?: string;
  products_url?: string;
  products?: { sku: string; name: string; image: string; item_ref: string }[];
  url?: string;
  image?: string;
  open_in_new_tab?: boolean;
  channels?: ("email" | "mobile" | "web_in_app")[];
  recipient_type?: "all" | "selected" | "tagged";
  selected_user_ids?: string[];
  selected_users?: { id: string; email: string; name: string }[];
  tag_ids?: string[];
}

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const auth = await authenticateTenant(req);
    if (!auth.authenticated || !auth.tenantDb) {
      return NextResponse.json({ error: auth.error || "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;
    const tenantDb = auth.tenantDb;
    const payload: UpdateCampaignPayload = await req.json();
    const { Campaign } = await connectWithModels(tenantDb);

    // Find campaign
    const campaign = await Campaign.findOne({ campaign_id: id });

    if (!campaign) {
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 });
    }

    // Only drafts can be updated
    if (campaign.status !== "draft") {
      return NextResponse.json(
        { error: "Only draft campaigns can be updated" },
        { status: 400 }
      );
    }

    // Validate and update fields
    if (payload.name !== undefined) {
      if (!payload.name.trim()) {
        return NextResponse.json({ error: "Campaign name cannot be empty" }, { status: 400 });
      }
      campaign.name = payload.name.trim();
      // Slug is auto-generated by pre-save hook
    }

    if (payload.type !== undefined) {
      if (!TEMPLATE_TYPES.includes(payload.type)) {
        return NextResponse.json({ error: "Invalid campaign type" }, { status: 400 });
      }
      campaign.type = payload.type;
    }

    if (payload.title !== undefined) {
      if (!payload.title.trim()) {
        return NextResponse.json({ error: "Title cannot be empty" }, { status: 400 });
      }
      campaign.title = payload.title.trim();
    }

    if (payload.body !== undefined) {
      if (!payload.body.trim()) {
        return NextResponse.json({ error: "Body cannot be empty" }, { status: 400 });
      }
      campaign.body = payload.body.trim();
    }

    if (payload.channels !== undefined) {
      if (!Array.isArray(payload.channels) || payload.channels.length === 0) {
        return NextResponse.json({ error: "At least one channel is required" }, { status: 400 });
      }
      for (const channel of payload.channels) {
        if (!NOTIFICATION_CHANNELS.includes(channel)) {
          return NextResponse.json({ error: `Invalid channel: ${channel}` }, { status: 400 });
        }
      }
      campaign.channels = payload.channels;
    }

    if (payload.recipient_type !== undefined) {
      if (!RECIPIENT_TYPES.includes(payload.recipient_type)) {
        return NextResponse.json({ error: "Invalid recipient type" }, { status: 400 });
      }
      campaign.recipient_type = payload.recipient_type;
    }

    // Update optional fields
    if (payload.push_image !== undefined) campaign.push_image = payload.push_image?.trim();
    if (payload.email_subject !== undefined) campaign.email_subject = payload.email_subject?.trim();
    if (payload.email_html !== undefined) campaign.email_html = payload.email_html;
    if (payload.products_url !== undefined) campaign.products_url = payload.products_url?.trim();
    if (payload.products !== undefined) campaign.products = payload.products;
    if (payload.url !== undefined) campaign.url = payload.url?.trim();
    if (payload.image !== undefined) campaign.image = payload.image?.trim();
    if (payload.open_in_new_tab !== undefined) campaign.open_in_new_tab = payload.open_in_new_tab;
    if (payload.selected_users !== undefined) {
      campaign.selected_users = payload.selected_users;
      campaign.selected_user_ids = payload.selected_users.map((u) => u.id);
    } else if (payload.selected_user_ids !== undefined) {
      campaign.selected_user_ids = payload.selected_user_ids;
    }
    if (payload.tag_ids !== undefined) campaign.tag_ids = payload.tag_ids;

    campaign.updated_by = auth.userId || auth.email;

    await campaign.save();

    return NextResponse.json({
      success: true,
      campaign: {
        campaign_id: campaign.campaign_id,
        name: campaign.name,
        slug: campaign.slug,
        status: campaign.status,
        type: campaign.type,
        title: campaign.title,
        updated_at: campaign.updated_at,
      },
      message: "Campaign updated",
    });
  } catch (error) {
    console.error("Error updating campaign:", error);
    return NextResponse.json(
      { error: "Failed to update campaign" },
      { status: 500 }
    );
  }
}

// ============================================
// DELETE - Delete campaign
// ============================================

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const auth = await authenticateTenant(req);
    if (!auth.authenticated || !auth.tenantDb) {
      return NextResponse.json({ error: auth.error || "Unauthorized" }, { status: 401 });
    }

    const { id } = await params;
    const tenantDb = auth.tenantDb;
    const { Campaign } = await connectWithModels(tenantDb);

    const campaign = await Campaign.findOne({ campaign_id: id });

    if (!campaign) {
      return NextResponse.json({ error: "Campaign not found" }, { status: 404 });
    }

    // Only drafts and failed campaigns can be deleted
    if (!["draft", "failed"].includes(campaign.status)) {
      return NextResponse.json(
        { error: "Only draft or failed campaigns can be deleted" },
        { status: 400 }
      );
    }

    await Campaign.deleteOne({ campaign_id: id });

    return NextResponse.json({
      success: true,
      message: "Campaign deleted",
    });
  } catch (error) {
    console.error("Error deleting campaign:", error);
    return NextResponse.json(
      { error: "Failed to delete campaign" },
      { status: 500 }
    );
  }
}
